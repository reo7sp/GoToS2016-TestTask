# GoToSchoolS2016-TestTask
Test task for GoTo Machine Learning School in summer 2016.

## Report on final task
[PDF](/3-report.pdf)

## Task

**Здравствуйте!**

Перед вами задание летней городской школы GoTo для направления по машинному обучению и анализу данных. Вам предлагается проанализировать данные о фильмах и научиться автоматически рекомендовать пользователям фильмы, которые с большей вероятностью им понравятся.

Предложенная задача - реальная задача с которой столкнулись специалисты по анализу данных нашего партнера – компании [E-Contenta](http://e-contenta.com/) при разработке рекомендательного движка для приложения [Tviz.tv](http://tviz.tv/). Часть данных была анонимизирована, как обычно делают компании, отдавая свои данные внешним аналитикам. Часть нужной информации отсутствует, поскольку в реальном мире сервера иногда ломаются и часть данных пропадает.

_Описание задач и baseline в помощь можно найти еще и на Хабре: https://habrahabr.ru/company/goto/blog/305526/_

**Давайте познакомимся с данными**

Архив с данными можно скачать [здесь](https://yadi.sk/d/SqsWFcpds9rTL).

В нём вы найдёте:

- train\_likes.csv - выборка о том, какому зрителю какие фильмы понравились,
- json - описание фильмов,
- csv - расписание фильмов.

Для сохранения приватности, все данные были анонимизированы - личные данные людей и каналов были заменены на идентификаторы. Одинаковые идентификаторы соответствуют одному и тому же человеку.

**train\_likes.csv**

Таблица со строками вида user\_id, item\_id, channel, time.

- user\_id - идентификатор зрителя
- item\_id - идентификатор фильма
- channel - идентификатор канала
- time - время (timestamp)

Каждая такая четвёрка означает, что в момент {time} пользователю {user\_id} понравился фильм {item\_id}, который шёл по каналу {channel}.

**items.json**

Метаданные о фильмах в формате json (открывается любым стандартным json модулем). Каждая строчка обязательно содержит:

- id - идентификатор фильма
- duration - коэффициент продолжительности фильма
- year - коэффициент года производства
- genre - номер жанра (категориальная переменная, всего 10 жанров)
- f\_{номер} - дополнительные признаки (см. ниже).

Коэффициенты duration и year - арифметические преобразования продолжительности фильма и года выпуска, сделанные для того, чтобы сохранить персональные данные.

Признаки f\_\* - различные анонимизированные признаки фильма. Примеры таких признаков - &quot;Страна производства - США&quot; или &quot;Бюджет больше $100к&quot; (да - 1, нет - 0 или не присутствует).

Важно! Строчки с описанием есть не у всех фильмов: описано примерно 2/3 фильмов, которые были лайкнуты.

**schedule.csv**

Таблица со строками вида time\_end, time\_start, item\_id, channel

- time\_end - время конца передачи
- time\_start - время начала передачи
- item\_id - id фильма
- channel - id канала

Пример чтения данных можно найти здесь: [https://gist.github.com/justheuristic/e582879e0aab458a058732245143fc6d](https://gist.github.com/justheuristic/e582879e0aab458a058732245143fc6d)

**Задание**

Главная задача – на основании имеющихся данных нужно проанализировать интересы пользователей и построить алгоритм рекомендации новых фильмов.

В начале Вам предлагается решить несколько простых аналитических задач (задачи 1 и 2) при помощи предложенных данных, после чего попытаться получить решение творческой задачи.

Идеальное решение задания должно содержать: ответ, программный код, воспроизводящий этот ответ, и описание того, что вы сделали. Решение рекомендуется присылать на языке Python (2.7 или 3.4/3.5). Можно использовать любые библиотеки, если вы готовы в разговоре объяснить, как они работают. Если вы &quot;списываете&quot;(заимствуете материалы из интернета, будьте добры сослаться на источник). Заимствование при указанном источнике не наказывается, если вы способны объяснить, что именно происходит в коде и почему он решает ту задачу, для которой вы его используете. Списывание без указания источника карается всегда.

**Задача 1**

Не все каналы и не все фильмы одинаково популярны. Для начала вычислите, сколько в среднем пользовательских лайков (train\_likes) есть у одного канала. Также посчитайте количество фильмов, у которых есть хотя бы 5 &quot;лайков&quot;.

Рекомендуемый формат вывода – одно вещественное число (среднее число лайков на канал) и одно целое (число фильмов с 5+ лайков).

**Задача 2**

У зрителей обычно есть свои жанровые предпочтения, причём эти предпочтения могут различаться от канала к каналу. Учтите, что не для всех фильмов известны их жанры - такие фильмы придётся посчитать отдельно.

Для начала вычислите сумму лайков для каждого жанра и отдельно - для фильмов, где жанр неизвестен.

Далее вычислите такую же сумму лайков по жанрам для каждого из топ-10 самых залайканных каналов.

Рекомендуемый формат вывода - строчка из чисел – число лайков каждого жанра по возрастанию номера жанра, в конце – число лайков для фильмов с неизвестным жанром. Далее 10 таких же строчек для каждого из топ-10 каналов по популярности. Нужно пояснить, какой именно канал показан на каждой строчке.

**Задача 3**

Ваша основная цель – научиться рекомендовать пользователям фильмы так, чтобы они им нравились.

Существует много способов это сделать, используя довольно простые предположения. Например:

- Вам нравятся фильмы похожие на те, которые вы уже полайкали. Если в выборке есть фильм, который по признакам (items.json) похож на другие фильмы, которые вам понравились, то скорее всего этот фильм вам тоже понравится.
- Похожим пользователям нравятся похожие фильмы. Если пользователи, которые лайкали те же фильмы, что и вы, как правило лайкают ещё 1 фильм, о котором вы не знаете, скорее всего этот фильм вам понравится.
- Каналы формируют свои программы так, что в одно время там идут программы, рассчитанные на примерно одну и ту же аудиторию.

и так далее…

От Вас в первую очередь требуется создать минимальное работоспособное решение. **Если вы ранее не использовали машинное обучение, можно попытаться использовать интуитивные соображения выше и &quot;hard-coded&quot; предсказательный алгоритм.**

Далеко не все такие идеи окажутся работоспособными, поэтому вам потребуется проверять, работает ли та или иная гипотеза. Например, чтобы проверить, насколько работает вторая идея (смотреть на похожих пользователей), можно вычислить долю случаев, на которых ваш алгоритм верно предсказывает решение (точность).

Более искушённым участникам предлагается воспользоваться метрикой [MAP@K](https://stackedit.io/viewer#!provider=gist&amp;gistId=de556eedb4dee5d7ca36eb922be40217&amp;filename=ranking_metrics) или [NDCG](https://stackedit.io/viewer#!provider=gist&amp;gistId=5a8d0c99415724f9ea04136cc7ec3e29&amp;filename=ranking_metrics_ndcg). Также вы можете предложить свою методику оценки качества и рассказать нам, почему вы выбрали именно ее.

**Рекомендуемый интерфейс – желательно, чтобы в вашей программе была функция, которая принимает параметры (id\_пользователя, id\_фильма, дополнительная информация) и возвращает предсказанную вероятность лайка.**

Главное, что будет влиять на оценку – работоспособность решения (значимо лучше, чем наугад), обоснованность оценки качества решения, и только потом - финальное качество. **Простое работающее решение, которое честно проанализировано, всегда лучше, чем безумная смесь всего того, что вы нашли в интернете, про которое не понятно, как оно работает и завышена оценка качества. Машинное обучение использовать желательно, но не обязательно.**

Кроме такой системы от вас хочется получить отчёт в произвольном формате, из которого можно понять, что именно вы делали и почему, а также как вы оценивали качество вашей рекомендательной системы. Рекомендуемый максимальный объём отчёта - 3000 символов, включая пробелы (assert len(u&quot;&quot;&quot;ваш отчёт&quot;&quot;&quot;) &lt;=3000).

**Удачи!**
